using System.Collections.Immutable;
using System.Text;
using EntityLengths.Generator.Configuration;
using EntityLengths.Generator.Core;
using EntityLengths.Generator.Extensions;
using EntityLengths.Generator.Extractors;
using EntityLengths.Generator.Models;
using EntityLengths.Generator.Options;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EntityLengths.Generator;

[Generator]
public class EntityMaxLengthGenerator : IIncrementalGenerator
{
    private readonly EntityLengthsOptionsProvider _optionsProvider = new();

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typeDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: IsSyntaxTargetForGeneration,
            transform: (syntaxContext, _) =>
            {
                var config = _optionsProvider.GetOptions(syntaxContext.SemanticModel.Compilation);
                var filter = new NamespaceFilter(config.ScanningOptions);

                // Skip if namespace doesn't match filters
                if (!filter.ShouldProcessNode(syntaxContext.Node, syntaxContext.SemanticModel))
                {
                    return null;
                }

                var classNode = (ClassDeclarationSyntax)syntaxContext.Node;

                // Check for IEntityTypeConfiguration
                if (classNode.IsEntityConfigurationClass())
                {
                    return new FluentConfigurationExtractor().ExtractPropertyLengths(syntaxContext);
                }

                // Check for DbContext
                if (classNode.IsDbContextClass())
                {
                    return new DbContextConfigurationExtractor().ExtractPropertyLengths(
                        syntaxContext
                    );
                }

                // Check for attributes
                return new AttributeExtractor().ExtractPropertyLengths(syntaxContext);
            }
        );

        var compiledTypes = typeDeclarations.Where(t => t != null).Collect();

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(compiledTypes),
            (spc, source) => GenerateOutput(spc, source.Left, source.Right)
        );
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node, CancellationToken _) =>
        node is ClassDeclarationSyntax;

    private void GenerateOutput(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<EntityTypeInfo?> types
    )
    {
        var options = _optionsProvider.GetOptions(compilation);

        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine("// <auto-generated/>");

        var ns = options.Namespace ?? compilation.AssemblyName;
        sourceBuilder.AppendLine($"namespace {ns};");
        sourceBuilder.AppendLine();

        if (options.GenerateDocumentation)
        {
            sourceBuilder.AppendLine("/// <summary>");
            sourceBuilder.AppendLine(
                "/// Contains generated string length constants for entity properties"
            );
            sourceBuilder.AppendLine("/// </summary>");
        }

        sourceBuilder.AppendLine(
            $"public static partial class {options.GeneratedClassName} \r\n{{"
        );

        var entityGroups = types
            .Where(t => t != null)
            .GroupBy(t => t!.EntityType.Name)
            .OrderBy(g => g.Key)
            .ToList();

        var isFirst = true;
        foreach (var entityGroup in entityGroups)
        {
            if (!isFirst)
                sourceBuilder.AppendLine();

            if (options.GenerateDocumentation)
            {
                sourceBuilder.AppendLine("\t/// <summary>");
                sourceBuilder.AppendLine($"\t/// Length constants for {entityGroup.Key}");
                sourceBuilder.AppendLine("\t/// </summary>");
            }

            var allProperties = entityGroup
                .SelectMany(c => c!.StringProperties)
                .GroupBy(p => p.PropertyName)
                .Select(g => g.First())
                .OrderBy(p => p.PropertyName)
                .ToList();

            GenerateEntityClass(sourceBuilder, entityGroup.Key, allProperties, options);
            isFirst = false;
        }

        sourceBuilder.AppendLine("}");

        context.AddSource($"{options.GeneratedClassName}.g.cs", sourceBuilder.ToString());
    }

    private static void GenerateEntityClass(
        StringBuilder sourceBuilder,
        string entityName,
        IReadOnlyCollection<PropertyMaxLength> properties,
        EntityLengthsGeneratorOptions options
    )
    {
        sourceBuilder.AppendLine($"\tpublic static partial class {entityName}");
        sourceBuilder.AppendLine("\t{");

        foreach (var prop in properties)
        {
            if (options.GenerateDocumentation)
            {
                sourceBuilder.AppendLine("\t\t/// <summary>");
                sourceBuilder.AppendLine($"\t\t/// Maximum length for {prop.PropertyName}");
                sourceBuilder.AppendLine("\t\t/// </summary>");
            }

            sourceBuilder.AppendLine(
                $"\t\tpublic const int {prop.PropertyName}{options.LengthSuffix} = {prop.MaxLength};"
            );
        }

        sourceBuilder.AppendLine("\t}");
    }
}
