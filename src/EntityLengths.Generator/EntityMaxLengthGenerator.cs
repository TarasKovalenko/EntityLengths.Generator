using System.Collections.Immutable;
using System.Text;
using EntityLengths.Generator.Attributes;
using EntityLengths.Generator.Configuration;
using EntityLengths.Generator.Core;
using EntityLengths.Generator.Extensions;
using EntityLengths.Generator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EntityLengths.Generator;

[Generator]
public class EntityMaxLengthGenerator : IIncrementalGenerator
{
    private const string EntityTypeConfigurationInterface = "IEntityTypeConfiguration";

    private readonly IPropertyLengthExtractor _fluentExtractor = new FluentConfigurationExtractor();
    private readonly IPropertyLengthExtractor _attributeExtractor = new AttributeExtractor();

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var providerConfigTypes = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: (s, _) => IsEntityConfigurationClass(s),
                transform: (syntaxContext, _) =>
                    _fluentExtractor.ExtractPropertyLengths(syntaxContext)
            )
            .Where(x => x != null);

        var entityTypesWithAttributes = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: (s, _) => s is ClassDeclarationSyntax,
                transform: (syntaxContext, _) =>
                    _attributeExtractor.ExtractPropertyLengths(syntaxContext)
            )
            .Where(x => x != null);

        var compilationAndConfigurations = context
            .CompilationProvider.Combine(providerConfigTypes.Collect())
            .Combine(entityTypesWithAttributes.Collect());

        context.RegisterSourceOutput(
            compilationAndConfigurations,
            (spc, source) =>
                GenerateEntityLengthsFile(spc, source.Left.Left, source.Left.Right, source.Right)
        );
    }

    private static bool IsEntityConfigurationClass(SyntaxNode syntaxNode)
    {
        return syntaxNode is ClassDeclarationSyntax classSyntax
            && classSyntax.BaseList?.Types.Any(t =>
                t.Type.ToString().StartsWith(EntityTypeConfigurationInterface)
            ) == true;
    }

    private static void GenerateEntityLengthsFile(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<EntityTypeInfo?> fluentConfigurations,
        ImmutableArray<EntityTypeInfo?> attributeConfigurations
    )
    {
        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine("// <auto-generated/>");
        sourceBuilder.AppendLine($"namespace {compilation.AssemblyName};");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("public static partial class EntityLengths \r\n{");

        GenerateConfigurationClasses(sourceBuilder, fluentConfigurations);

        if (attributeConfigurations.Any() && fluentConfigurations.Any())
        {
            sourceBuilder.AppendLine();
        }

        GenerateConfigurationClasses(sourceBuilder, attributeConfigurations);
        sourceBuilder.AppendLine("}");

        context.AddSource("EntityLengths.g.cs", sourceBuilder.ToString());
    }

    private static void GenerateConfigurationClasses(
        StringBuilder sourceBuilder,
        ImmutableArray<EntityTypeInfo?> configurations
    )
    {
        for (var index = 0; index < configurations.Length; index++)
        {
            var configuration = configurations[index];
            if (configuration is null)
            {
                continue;
            }

            GenerateEntityClass(sourceBuilder, configuration);

            if (index < configurations.Length - 1)
            {
                sourceBuilder.AppendLine();
            }
        }
    }

    private static void GenerateEntityClass(
        StringBuilder sourceBuilder,
        EntityTypeInfo configuration
    )
    {
        sourceBuilder.AppendLine($"\tpublic static partial class {configuration.EntityType.Name}");
        sourceBuilder.AppendLine("\t{");

        foreach (var prop in configuration.StringProperties.DistinctBy(p => p.PropertyName))
        {
            sourceBuilder.AppendLine(
                $"\t\tpublic const int {prop.PropertyName}Length = {prop.MaxLength};"
            );
        }

        sourceBuilder.AppendLine("\t}");
    }
}
